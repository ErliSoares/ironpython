# Practical 1: Create a 'Post' button
# MainForm.py, MainForm.__init__()
In the MainForm.__init__, create new .NET Button, and store it as 
self.postButton. Label the button 'Post'. Add this button, not to the
form itself, but to the form's upper panel control.

Answer:
in __init__():
    self.postButton = Button()
    self.postButton.Text = "Post"
in _layout():
    upperPanel.Controls.Add(self.postButton)


# Practical 2: GUI Layout
# MainForm.py, _layout()
Anwer: just uncomment the lines there


# Practical 3: Add menu items for 'Refresh' and 'Quit'
# MainForm.py, MainForm._addMenu()

Answer:
    self.refreshMenuItem = ToolStripMenuItem("Refresh")
    stutterMenu.DropDownItems.Add(self.refreshMenuItem)

    self.quitMenuItem = ToolStripMenuItem("Quit")
    stutterMenu.DropDownItems.Add(self.quitMenuItem)

    self.menuStrip.Dock = DockStyle.Top
    self.Controls.Add(self.menuStrip)


# Practical 4: Add handlers for 'refresh' and 'quit'
# Use the 'onRefresh' function as a 'Refresh' menu item handler
# Write an onQuit and add that as a 'Quit' handler
# stutter.py, Stutter.__init__()

Answer:
    self.form.refreshMenuItem.Click += self.onRefresh
    self.form.quitMenuItem.Click += self.onQuit

    def onQuit(self, source, args):
        Application.Exit()


# Practical 5: Add update support
# In Client.py, impliment Client.update() method

Answer
    def update(self, text):
        request = WebRequest.Create(self.url_base + '/statuses/update.xml')
        request.Credentials = self.credentials
        request.Method = 'POST'

        writer = StreamWriter(request.GetRequestStream())
        postData = urllib.urlencode(dict(status=text))
        writer.WriteLine(postData)
        writer.Close()

        response = request.GetResponse()
        reader = StatusReader()
        tweets = reader.read(StreamReader(response.GetResponseStream()))
        assert len(tweets) == 1, "expecting just one update response"
        return tweets[0]


----------



# Exercise E: download and save the image in the cache
# TweetPanel.py, getImage()

Answer:
    try:
        imageBytes = WebClient().DownloadData(tweet['image_url'])
        image = Bitmap(MemoryStream(imageBytes))        
    except:
        return Bitmap.FromFile(os.path.join('imagecache', '__fallback__.png'))
    else:
        image.Save(cacheLocation)
        return image



# Exercise H: Add a handler for the friendListBox.SelectedIndexChanged event.
# stutter.py, Stutter.__init__()

Answer:
    self.form.friendsListBox.SelectedIndexChanged += self.onSelectFriend

    def onSelectFriend(self, source, args):
        self.displayTweets()

    def displayTweets(self):
        selectedFriend = None
        if self.form.friendsListBox.SelectedIndex != 0:
            selectedFriend = self.form.friendsListBox.SelectedItem
        self.form.showTweets(stutterdb.getTweets(selectedFriend))


# Exercuse I: Add a handler for the 'Post' Button
# stutter.py, Stutter.__init__()

Answer:
    self.form.postButton.Click += self.onPost

    def onPost(self, source, args):
        tweet = self.client.update(self.form.postTextBox.Text)
        stutterdb.saveTweet(tweet)
        self.form.postTextBox.Text = ''
        self.displayTweets()


# Exercise K: Implement DoBackgroundWithInvoke()
# threadhelper.py
Answer:
    from System.Threading import Thread, ThreadStart

    def DoBackgroundWithInvoke(function, callback, form):
        def op():
            function()
            form.Invoke(CallTarget0(callback))
        t = Thread(ThreadStart(op))
        t.Start()


# Exercse L1: Write db access functions to save and load to database
# stutterdb.py, saveFriend(), saveTweet(), getFriends(), getTweets()
Answer:
    def saveFriend(friend):
        if itemExists('friends', friend['id']):
            return

        cmd = conn.CreateCommand()
        cmd.CommandText = SAVE_FRIEND_STATEMENT
        for name in friendAttrs:
            setParameter(cmd, name, friend.get(name))
        cmd.ExecuteNonQuery()


    def getFriends():
        cmd = conn.CreateCommand()
        cmd.CommandText = GET_FRIENDS_STATEMENT
        reader = cmd.ExecuteReader()
        try:
            friends = []
            while reader.Read():
                friends.append(reader['screen_name'])
        finally:
            reader.Close()
        return friends


    def saveTweet(tweet):
        if itemExists('tweets', tweet['id']):
            return

        friend = tweet.pop('user')
        saveFriend(friend)

        cmd = conn.CreateCommand()
        cmd.CommandText = SAVE_TWEET_STATEMENT
        for key, value in tweet.iteritems():
            setParameter(cmd, key, value)

        setParameter(cmd, 'friend_id', friend['id'])
        cmd.ExecuteNonQuery()
        

    def getTweets(friend=None):
        cmd = conn.CreateCommand()
        cmd.CommandText = GET_TWEETS_STATEMENT
        setParameter(cmd, 'friend', friend)
        reader = cmd.ExecuteReader()
        try:
            tweets = []
            while reader.Read():
                tweets.append(makeTweet(reader))
        finally:
            reader.Close()
        return tweets

